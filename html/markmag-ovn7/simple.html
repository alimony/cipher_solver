<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>markmag-ovn7.simple API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>markmag-ovn7.simple</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import Counter
from random import randint
from string import ascii_lowercase

import numpy as np
from consts import (
    DIGRAM_MATRIX_ENGLISH,
    ENGLISH_LETTERS_BY_FREQUENCY,
    STANDARD_ALPHABET_SIZE,
)


class SimpleSolver:
    &#34;&#34;&#34;Solver for simple monoalphabetic substitution ciphers.

    This solver is based on the paper
    &#34;A Fast Method for the Cryptanalysis of Substitution Ciphers&#34; by Thomas Jakobsen.
    The details of the algorithm is described in the solve method docstrings.

    The following terminology is used:

    &#34;ciphertext&#34; : The encrypted text we want to solve to get a plaintext.
    &#34;plaintext&#34; : The decrypted plaintext using a certain decryption key.
    &#34;common key&#34; : Key used to generate a plaintext, ordered by most common letter.
    &#34;alphabetical key&#34; : Decryption key, but ordered alphabetically.
    &#34;decryption key&#34; : Assumed to mean a common key if nothing else is specified.
    &#34;digram&#34; : A pair of letters, e.g. &#34;aa&#34;, &#34;cd&#34; etc.
    &#34;digram matrix&#34; : An (n x n) matrix, where n is the length of the used alphabet,
                      created from a given text, where the frequency of each digram
                      relative to the text length is saved to the corresponding index
                      pair, e.g. (0, 0) for &#34;aa&#34;, (0, 1) for &#34;ab&#34; etc.
    &#34;&#34;&#34;

    def __init__(self, ciphertext):
        &#34;&#34;&#34;Create new solver.

        Creates a new cipher solver from an initial ciphertext.

        Parameters
        ----------
        ciphertext : str
            The ciphertext to solve.

        Raises
        ------
        ValueError
            If the passed ciphertext is not a string.
            If the passed ciphertext is empty.
        &#34;&#34;&#34;

        if not isinstance(ciphertext, str):
            raise ValueError(f&#34;{ciphertext} is not a string.&#34;)

        if len(ciphertext) &lt; 1:
            raise ValueError(&#34;Ciphertext cannot be empty.&#34;)

        # The decryption key is a string of letters that determines how the ciphertext
        # is converted to plaintext. The key is equal in length to the English alphabet
        # and is assumed to be in frequency order. In other words, the first letter is
        # the letter in the ciphertext that should be translated to an &#34;e&#34;, the second
        # which one should be converted to a &#34;t&#34;, and so on. When generating plaintext
        # this key will be converted to an alphabetical one that matches the order of
        # English alphabet which is the common way to express decryption keys.
        self._decryption_key = self._get_initial_key(ciphertext)

        self._ciphertext = ciphertext.lower()

    def _score(self, matrix1, matrix2=DIGRAM_MATRIX_ENGLISH):
        &#34;&#34;&#34;Calculate a score for passed digram matrices using the distance sum method.

        The score is defined as the sum of all the absolute differences between each
        corresponding element in the two matrices.

        Parameters
        ----------
        matrix1 : numpy.array
            The first matrix to use in the comparison.
        matrix2 : numpy.array
            The second matrix to use in the comparison. Defaults to English digrams.

        Returns
        -------
        score : float
            The distance sum of the two matrices.

        Raises
        ------
        ValueError
            If the passed matrices don&#39;t have the same number of rows and columns.
        &#34;&#34;&#34;

        if matrix1.shape != matrix2.shape:
            raise ValueError(&#34;Digram matrices must have the same dimensions&#34;)

        return abs(matrix1 - matrix2).sum()

    def _get_common_letters(self, text):
        &#34;&#34;&#34;Get all unique letters of the passed text, sorted by frequency.

        Parameters
        ----------
        text : str
            The text to find most common letters for.

        Returns
        -------
        common_letters : str
            The letters of the text ordered by frequency.

        Raises
        ------
            If the passed text is not a string.
            If the passed text is empty.
        &#34;&#34;&#34;

        if not isinstance(text, str):
            raise ValueError(&#34;{text} is not a string.&#34;)

        if len(text) &lt; 1:
            raise ValueError(&#34;Text must not be empty.&#34;)

        c = Counter(text)
        return &#34;&#34;.join([letter[0] for letter in c.most_common()])

    def _get_digram_matrix(self, text, alphabet_size=STANDARD_ALPHABET_SIZE):
        &#34;&#34;&#34;Generate digram matrix for the passed text.

        Parameters
        ----------
        text : str
            Text to generate digram frequency matrix for.
        alphabet_size : int
            The number of letters in the cipher alphabet, defaults to English length.

        Returns
        -------
        digram_matrix : numpy.array
            An array of digram frequencies indexed by [first][second] letter.

        Raises
        ------
        ValueError
            If the passed alphabet size is less than one
            If the passed alphabet size is not an integer.
            If the passed text does not contain at least one digram.
        &#34;&#34;&#34;

        if not isinstance(alphabet_size, int):
            raise ValueError(&#34;Alphabet size must be an integer.&#34;)

        if alphabet_size &lt; 1:
            raise ValueError(&#34;Alphabet must contain at least one letter.&#34;)

        if len(text) &lt; 2:
            raise ValueError(&#34;Text must contain at least one digram.&#34;)

        digram_matrix = np.zeros((alphabet_size, alphabet_size))

        text = text.lower()
        text_length = len(text)

        # First, count the number of occurrences of each letter and save to the index
        # that corresponds to the letter pair, i.e. digram_matrix[0, 0] is for &#34;aa&#34; etc.
        for i in range(0, text_length - 1):
            a = ascii_lowercase.index(text[i])
            b = ascii_lowercase.index(text[i + 1])
            digram_matrix[a, b] += 1

        # Replace each entry with a percentage of the total text length, to get the same
        # format as the English digram matrix.
        rows, columns = digram_matrix.shape
        for i in range(rows):
            for j in range(columns):
                # All digram frequencies are in percentages, so convert it here too.
                digram_matrix[i, j] = 100 * digram_matrix[i, j] / text_length

        return digram_matrix

    def _get_plaintext(self, decryption_key):
        &#34;&#34;&#34;Return a plaintext using the passed decryption key.

        Parameters
        ----------
        decryption_key : str
            The decryption key to use for generating the plaintext.

        Returns
        -------
        plaintext : str
            Plaintext from decrypting the ciphertext using the current decryption key.

        Raises
        ------
        ValueError
            If the passed decryption key does not contain all letters of the alphabet.
        &#34;&#34;&#34;

        if len(set(decryption_key)) != STANDARD_ALPHABET_SIZE:
            raise ValueError(f&#34;Key must include all letters of the alphabet.&#34;)

        # The decryption key will be in order of most common first, so we need to
        # construct a list of indices where to insert each to get an &#34;alphabetical key&#34;
        # instead.
        indices = [
            ascii_lowercase.index(letter) for letter in ENGLISH_LETTERS_BY_FREQUENCY
        ]

        translation_table = {}

        for key_letter, index in zip(decryption_key, indices):
            plain_letter = ascii_lowercase[index]
            translation_table[key_letter] = plain_letter

        return &#34;&#34;.join([translation_table[c] for c in self._ciphertext])

    def _get_initial_key(self, ciphertext):
        &#34;&#34;&#34;Construct the initial decryption key.

        The initial decryption key is based on the letter frequencies in the ciphertext,
        meaning an assumption that the most common letter in the ciphertext translates
        to the most common letter in the English language, and so on. Any letters not
        present in the ciphertext will be added alphabetically at the end of the key.

        Parameters
        ----------
        ciphertext : str
            The ciphertext to generate an initial decryption key from.

        Returns
        -------
        decryption_key : str
            The initial decryption key.

        Raises
        ------
        ValueError
            If the passed ciphertext is not a string.
            If the passed ciphertext is empty.
        &#34;&#34;&#34;

        if not isinstance(ciphertext, str):
            raise ValueError(f&#34;{ciphertext} is not a string.&#34;)

        if len(ciphertext) &lt; 1:
            raise ValueError(&#34;Ciphertext cannot be empty.&#34;)

        decryption_key = self._get_common_letters(ciphertext)

        for c in ascii_lowercase:
            if c not in decryption_key:
                decryption_key += c

        return &#34;&#34;.join(decryption_key)

    def _swap(self, matrix, index1, index2):
        &#34;&#34;&#34;Swap the matrix rows and columns at the given indices.

        Parameters
        ----------
        matrix : numpy.array
            The matrix to modify in-place.
        index1 : int
            The first index to swap between.
        index2 : int
            The second index to swap between.

        Raises
        ------
        ValueError
            If the passed matrix is not square.
        &#34;&#34;&#34;

        rows, columns = matrix.shape

        if rows != columns:
            raise ValueError(&#34;Matrix must be square.&#34;)

        # Swap rows:
        matrix[[index1, index2]] = matrix[[index2, index1]]

        # Swap columns:
        matrix[:, [index1, index2]] = matrix[:, [index2, index1]]

    def _solve_naive(self):
        &#34;&#34;&#34;Solve cipher using the naive algorithm based on random key swaps.

        This is the first algorithm described by Jakobsen. It is slow because a
        plaintext has to be generated and a digram matrix calculated for each iteration.
        The algorithm works as follows:

        1. Create an initial key that is the ciphertext letters ordered by frequency.
        2. Generate a putative plaintext using this key.
        3. Calculate a digram matrix from this plaintext.
        4. Calculate a score from this digram matrix using the distance sum method.
        5. Repeat the following steps:
            6a. Make a copy of the key.
            6b. Swap two elements at random in this putative key.
            6c. After each swap, generate a putative plaintext, its digram matrix, and
                the score of this putative digram matrix.
            6d. If the score improved, save the modified key as the new best key, and
                save the improved score as the new best score.
        7. The algorithm is done when the score hasn&#39;t improved for 1,000 iterations.
        &#34;&#34;&#34;

        # We need the key as a list so we can modify it in-place.
        key = [c for c in self._decryption_key]

        # Generate an initial digram matrix.
        putative_plaintext = self._get_plaintext(key)
        digram_matrix = self._get_digram_matrix(putative_plaintext)

        best_score = self._score(digram_matrix)

        iterations_since_last_improvement = 0

        # Loop and swap elements in the key at random until the score hasn&#39;t improved
        # for 1,000 iterations.
        while iterations_since_last_improvement &lt; 1000:
            putative_key = key[:]

            a = randint(0, 25)
            b = randint(0, 25)
            putative_key[a], putative_key[b] = putative_key[b], putative_key[a]

            plaintext = self._get_plaintext(putative_key)
            putative_digram_matrix = self._get_digram_matrix(plaintext)

            score = self._score(putative_digram_matrix)

            iterations_since_last_improvement += 1

            if score &lt; best_score:
                best_score = score
                key = putative_key[:]
                iterations_since_last_improvement = 0

        self._decryption_key = &#34;&#34;.join(key)

    def _solve_fast(self):
        &#34;&#34;&#34;Solve the cipher using the fast algorithm based on digram matrix swaps.

        This is the second algorithm described by Jakobsen. It is based on the insight
        that swapping rows and columns in a digram matrix is equivalent to swapping the
        elements at the same indices in the key that was used to generate the plaintext
        that was used to generate the digram matrix. The algorithm works as follows:

        1. Create an initial key that is the ciphertext letters ordered by frequency.
        2. Generate a putative plaintext using this key.
        3. Calculate a digram matrix from this plaintext.
        4. Calculate a score from this digram matrix using the distance sum method.
        5. Repeat the following steps:
            6a. Make a copy of the digram matrix.
            6b. Swap rows/elements of the digram matrix at index (0, 1), (1, 2), (2, 3)
                etc. until the last index of the pair reaches the alphabet length. Then
                swap rows/columns at index (0, 2), (1, 3), (2, 4) etc. until the last
                index in the pair reaches the alphabet length. The last swap in this
                nested loop will be (0, 25).
            6c. After each swap, calculate a score from the modified digram matrix.
            6d. If the score improved, save the modified digram matrix as the new best
                matrix, make the same swap in the key and save it as the new best key,
                and save the improved score as the new best score.
        7. The algorithm is done when all swaps have been made.
        &#34;&#34;&#34;

        # We need this as a list so we can modify it in-place.
        key = [c for c in self._decryption_key]

        # Generate digram matrix from the corresponding plaintext.
        putative_plaintext = self._get_plaintext(key)
        digram_matrix = self._get_digram_matrix(putative_plaintext)

        # Calculate initial score.
        best_score = self._score(digram_matrix)

        # Loop and swap rows/columns in digram matrix.
        for i in range(1, STANDARD_ALPHABET_SIZE):
            for j in range(STANDARD_ALPHABET_SIZE - i):
                # Try a potential swap in the digram matrix.
                d = np.copy(digram_matrix)
                self._swap(d, j, j + i)

                score = self._score(d)

                if score &lt; best_score:
                    # The score improved, so commit this change in both the digram
                    # matrix and the key.
                    digram_matrix = d
                    key[j], key[j + i] = key[j + i], key[j]
                    best_score = score

        self._decryption_key = &#34;&#34;.join(key)

    def solve(self):
        &#34;&#34;&#34;Solve the cipher.

        Run the solver and save the resulting decryption key.
        &#34;&#34;&#34;

        # We currently use the slow, naive algorithm based on random key swaps.
        self._solve_naive()

    def plaintext(self):
        &#34;&#34;&#34;Return a plaintext using the current decryption key.

        Returns
        -------
        plaintext : str
            Plaintext from decrypting the ciphertext using the current decryption key.
        &#34;&#34;&#34;

        return self._get_plaintext(self._decryption_key)

    def reset(self):
        &#34;&#34;&#34;Reset the solver to its initial state.

        Set the decryption key to its initial state, effectively starting over.
        &#34;&#34;&#34;

        self._decryption_key = self._get_initial_key(self._ciphertext)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="markmag-ovn7.simple.SimpleSolver"><code class="flex name class">
<span>class <span class="ident">SimpleSolver</span></span>
<span>(</span><span>ciphertext)</span>
</code></dt>
<dd>
<div class="desc"><p>Solver for simple monoalphabetic substitution ciphers.</p>
<p>This solver is based on the paper
"A Fast Method for the Cryptanalysis of Substitution Ciphers" by Thomas Jakobsen.
The details of the algorithm is described in the solve method docstrings.</p>
<p>The following terminology is used:</p>
<p>"ciphertext" : The encrypted text we want to solve to get a plaintext.
"plaintext" : The decrypted plaintext using a certain decryption key.
"common key" : Key used to generate a plaintext, ordered by most common letter.
"alphabetical key" : Decryption key, but ordered alphabetically.
"decryption key" : Assumed to mean a common key if nothing else is specified.
"digram" : A pair of letters, e.g. "aa", "cd" etc.
"digram matrix" : An (n x n) matrix, where n is the length of the used alphabet,
created from a given text, where the frequency of each digram
relative to the text length is saved to the corresponding index
pair, e.g. (0, 0) for "aa", (0, 1) for "ab" etc.</p>
<p>Create new solver.</p>
<p>Creates a new cipher solver from an initial ciphertext.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ciphertext</code></strong> :&ensp;<code>str</code></dt>
<dd>The ciphertext to solve.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the passed ciphertext is not a string.
If the passed ciphertext is empty.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimpleSolver:
    &#34;&#34;&#34;Solver for simple monoalphabetic substitution ciphers.

    This solver is based on the paper
    &#34;A Fast Method for the Cryptanalysis of Substitution Ciphers&#34; by Thomas Jakobsen.
    The details of the algorithm is described in the solve method docstrings.

    The following terminology is used:

    &#34;ciphertext&#34; : The encrypted text we want to solve to get a plaintext.
    &#34;plaintext&#34; : The decrypted plaintext using a certain decryption key.
    &#34;common key&#34; : Key used to generate a plaintext, ordered by most common letter.
    &#34;alphabetical key&#34; : Decryption key, but ordered alphabetically.
    &#34;decryption key&#34; : Assumed to mean a common key if nothing else is specified.
    &#34;digram&#34; : A pair of letters, e.g. &#34;aa&#34;, &#34;cd&#34; etc.
    &#34;digram matrix&#34; : An (n x n) matrix, where n is the length of the used alphabet,
                      created from a given text, where the frequency of each digram
                      relative to the text length is saved to the corresponding index
                      pair, e.g. (0, 0) for &#34;aa&#34;, (0, 1) for &#34;ab&#34; etc.
    &#34;&#34;&#34;

    def __init__(self, ciphertext):
        &#34;&#34;&#34;Create new solver.

        Creates a new cipher solver from an initial ciphertext.

        Parameters
        ----------
        ciphertext : str
            The ciphertext to solve.

        Raises
        ------
        ValueError
            If the passed ciphertext is not a string.
            If the passed ciphertext is empty.
        &#34;&#34;&#34;

        if not isinstance(ciphertext, str):
            raise ValueError(f&#34;{ciphertext} is not a string.&#34;)

        if len(ciphertext) &lt; 1:
            raise ValueError(&#34;Ciphertext cannot be empty.&#34;)

        # The decryption key is a string of letters that determines how the ciphertext
        # is converted to plaintext. The key is equal in length to the English alphabet
        # and is assumed to be in frequency order. In other words, the first letter is
        # the letter in the ciphertext that should be translated to an &#34;e&#34;, the second
        # which one should be converted to a &#34;t&#34;, and so on. When generating plaintext
        # this key will be converted to an alphabetical one that matches the order of
        # English alphabet which is the common way to express decryption keys.
        self._decryption_key = self._get_initial_key(ciphertext)

        self._ciphertext = ciphertext.lower()

    def _score(self, matrix1, matrix2=DIGRAM_MATRIX_ENGLISH):
        &#34;&#34;&#34;Calculate a score for passed digram matrices using the distance sum method.

        The score is defined as the sum of all the absolute differences between each
        corresponding element in the two matrices.

        Parameters
        ----------
        matrix1 : numpy.array
            The first matrix to use in the comparison.
        matrix2 : numpy.array
            The second matrix to use in the comparison. Defaults to English digrams.

        Returns
        -------
        score : float
            The distance sum of the two matrices.

        Raises
        ------
        ValueError
            If the passed matrices don&#39;t have the same number of rows and columns.
        &#34;&#34;&#34;

        if matrix1.shape != matrix2.shape:
            raise ValueError(&#34;Digram matrices must have the same dimensions&#34;)

        return abs(matrix1 - matrix2).sum()

    def _get_common_letters(self, text):
        &#34;&#34;&#34;Get all unique letters of the passed text, sorted by frequency.

        Parameters
        ----------
        text : str
            The text to find most common letters for.

        Returns
        -------
        common_letters : str
            The letters of the text ordered by frequency.

        Raises
        ------
            If the passed text is not a string.
            If the passed text is empty.
        &#34;&#34;&#34;

        if not isinstance(text, str):
            raise ValueError(&#34;{text} is not a string.&#34;)

        if len(text) &lt; 1:
            raise ValueError(&#34;Text must not be empty.&#34;)

        c = Counter(text)
        return &#34;&#34;.join([letter[0] for letter in c.most_common()])

    def _get_digram_matrix(self, text, alphabet_size=STANDARD_ALPHABET_SIZE):
        &#34;&#34;&#34;Generate digram matrix for the passed text.

        Parameters
        ----------
        text : str
            Text to generate digram frequency matrix for.
        alphabet_size : int
            The number of letters in the cipher alphabet, defaults to English length.

        Returns
        -------
        digram_matrix : numpy.array
            An array of digram frequencies indexed by [first][second] letter.

        Raises
        ------
        ValueError
            If the passed alphabet size is less than one
            If the passed alphabet size is not an integer.
            If the passed text does not contain at least one digram.
        &#34;&#34;&#34;

        if not isinstance(alphabet_size, int):
            raise ValueError(&#34;Alphabet size must be an integer.&#34;)

        if alphabet_size &lt; 1:
            raise ValueError(&#34;Alphabet must contain at least one letter.&#34;)

        if len(text) &lt; 2:
            raise ValueError(&#34;Text must contain at least one digram.&#34;)

        digram_matrix = np.zeros((alphabet_size, alphabet_size))

        text = text.lower()
        text_length = len(text)

        # First, count the number of occurrences of each letter and save to the index
        # that corresponds to the letter pair, i.e. digram_matrix[0, 0] is for &#34;aa&#34; etc.
        for i in range(0, text_length - 1):
            a = ascii_lowercase.index(text[i])
            b = ascii_lowercase.index(text[i + 1])
            digram_matrix[a, b] += 1

        # Replace each entry with a percentage of the total text length, to get the same
        # format as the English digram matrix.
        rows, columns = digram_matrix.shape
        for i in range(rows):
            for j in range(columns):
                # All digram frequencies are in percentages, so convert it here too.
                digram_matrix[i, j] = 100 * digram_matrix[i, j] / text_length

        return digram_matrix

    def _get_plaintext(self, decryption_key):
        &#34;&#34;&#34;Return a plaintext using the passed decryption key.

        Parameters
        ----------
        decryption_key : str
            The decryption key to use for generating the plaintext.

        Returns
        -------
        plaintext : str
            Plaintext from decrypting the ciphertext using the current decryption key.

        Raises
        ------
        ValueError
            If the passed decryption key does not contain all letters of the alphabet.
        &#34;&#34;&#34;

        if len(set(decryption_key)) != STANDARD_ALPHABET_SIZE:
            raise ValueError(f&#34;Key must include all letters of the alphabet.&#34;)

        # The decryption key will be in order of most common first, so we need to
        # construct a list of indices where to insert each to get an &#34;alphabetical key&#34;
        # instead.
        indices = [
            ascii_lowercase.index(letter) for letter in ENGLISH_LETTERS_BY_FREQUENCY
        ]

        translation_table = {}

        for key_letter, index in zip(decryption_key, indices):
            plain_letter = ascii_lowercase[index]
            translation_table[key_letter] = plain_letter

        return &#34;&#34;.join([translation_table[c] for c in self._ciphertext])

    def _get_initial_key(self, ciphertext):
        &#34;&#34;&#34;Construct the initial decryption key.

        The initial decryption key is based on the letter frequencies in the ciphertext,
        meaning an assumption that the most common letter in the ciphertext translates
        to the most common letter in the English language, and so on. Any letters not
        present in the ciphertext will be added alphabetically at the end of the key.

        Parameters
        ----------
        ciphertext : str
            The ciphertext to generate an initial decryption key from.

        Returns
        -------
        decryption_key : str
            The initial decryption key.

        Raises
        ------
        ValueError
            If the passed ciphertext is not a string.
            If the passed ciphertext is empty.
        &#34;&#34;&#34;

        if not isinstance(ciphertext, str):
            raise ValueError(f&#34;{ciphertext} is not a string.&#34;)

        if len(ciphertext) &lt; 1:
            raise ValueError(&#34;Ciphertext cannot be empty.&#34;)

        decryption_key = self._get_common_letters(ciphertext)

        for c in ascii_lowercase:
            if c not in decryption_key:
                decryption_key += c

        return &#34;&#34;.join(decryption_key)

    def _swap(self, matrix, index1, index2):
        &#34;&#34;&#34;Swap the matrix rows and columns at the given indices.

        Parameters
        ----------
        matrix : numpy.array
            The matrix to modify in-place.
        index1 : int
            The first index to swap between.
        index2 : int
            The second index to swap between.

        Raises
        ------
        ValueError
            If the passed matrix is not square.
        &#34;&#34;&#34;

        rows, columns = matrix.shape

        if rows != columns:
            raise ValueError(&#34;Matrix must be square.&#34;)

        # Swap rows:
        matrix[[index1, index2]] = matrix[[index2, index1]]

        # Swap columns:
        matrix[:, [index1, index2]] = matrix[:, [index2, index1]]

    def _solve_naive(self):
        &#34;&#34;&#34;Solve cipher using the naive algorithm based on random key swaps.

        This is the first algorithm described by Jakobsen. It is slow because a
        plaintext has to be generated and a digram matrix calculated for each iteration.
        The algorithm works as follows:

        1. Create an initial key that is the ciphertext letters ordered by frequency.
        2. Generate a putative plaintext using this key.
        3. Calculate a digram matrix from this plaintext.
        4. Calculate a score from this digram matrix using the distance sum method.
        5. Repeat the following steps:
            6a. Make a copy of the key.
            6b. Swap two elements at random in this putative key.
            6c. After each swap, generate a putative plaintext, its digram matrix, and
                the score of this putative digram matrix.
            6d. If the score improved, save the modified key as the new best key, and
                save the improved score as the new best score.
        7. The algorithm is done when the score hasn&#39;t improved for 1,000 iterations.
        &#34;&#34;&#34;

        # We need the key as a list so we can modify it in-place.
        key = [c for c in self._decryption_key]

        # Generate an initial digram matrix.
        putative_plaintext = self._get_plaintext(key)
        digram_matrix = self._get_digram_matrix(putative_plaintext)

        best_score = self._score(digram_matrix)

        iterations_since_last_improvement = 0

        # Loop and swap elements in the key at random until the score hasn&#39;t improved
        # for 1,000 iterations.
        while iterations_since_last_improvement &lt; 1000:
            putative_key = key[:]

            a = randint(0, 25)
            b = randint(0, 25)
            putative_key[a], putative_key[b] = putative_key[b], putative_key[a]

            plaintext = self._get_plaintext(putative_key)
            putative_digram_matrix = self._get_digram_matrix(plaintext)

            score = self._score(putative_digram_matrix)

            iterations_since_last_improvement += 1

            if score &lt; best_score:
                best_score = score
                key = putative_key[:]
                iterations_since_last_improvement = 0

        self._decryption_key = &#34;&#34;.join(key)

    def _solve_fast(self):
        &#34;&#34;&#34;Solve the cipher using the fast algorithm based on digram matrix swaps.

        This is the second algorithm described by Jakobsen. It is based on the insight
        that swapping rows and columns in a digram matrix is equivalent to swapping the
        elements at the same indices in the key that was used to generate the plaintext
        that was used to generate the digram matrix. The algorithm works as follows:

        1. Create an initial key that is the ciphertext letters ordered by frequency.
        2. Generate a putative plaintext using this key.
        3. Calculate a digram matrix from this plaintext.
        4. Calculate a score from this digram matrix using the distance sum method.
        5. Repeat the following steps:
            6a. Make a copy of the digram matrix.
            6b. Swap rows/elements of the digram matrix at index (0, 1), (1, 2), (2, 3)
                etc. until the last index of the pair reaches the alphabet length. Then
                swap rows/columns at index (0, 2), (1, 3), (2, 4) etc. until the last
                index in the pair reaches the alphabet length. The last swap in this
                nested loop will be (0, 25).
            6c. After each swap, calculate a score from the modified digram matrix.
            6d. If the score improved, save the modified digram matrix as the new best
                matrix, make the same swap in the key and save it as the new best key,
                and save the improved score as the new best score.
        7. The algorithm is done when all swaps have been made.
        &#34;&#34;&#34;

        # We need this as a list so we can modify it in-place.
        key = [c for c in self._decryption_key]

        # Generate digram matrix from the corresponding plaintext.
        putative_plaintext = self._get_plaintext(key)
        digram_matrix = self._get_digram_matrix(putative_plaintext)

        # Calculate initial score.
        best_score = self._score(digram_matrix)

        # Loop and swap rows/columns in digram matrix.
        for i in range(1, STANDARD_ALPHABET_SIZE):
            for j in range(STANDARD_ALPHABET_SIZE - i):
                # Try a potential swap in the digram matrix.
                d = np.copy(digram_matrix)
                self._swap(d, j, j + i)

                score = self._score(d)

                if score &lt; best_score:
                    # The score improved, so commit this change in both the digram
                    # matrix and the key.
                    digram_matrix = d
                    key[j], key[j + i] = key[j + i], key[j]
                    best_score = score

        self._decryption_key = &#34;&#34;.join(key)

    def solve(self):
        &#34;&#34;&#34;Solve the cipher.

        Run the solver and save the resulting decryption key.
        &#34;&#34;&#34;

        # We currently use the slow, naive algorithm based on random key swaps.
        self._solve_naive()

    def plaintext(self):
        &#34;&#34;&#34;Return a plaintext using the current decryption key.

        Returns
        -------
        plaintext : str
            Plaintext from decrypting the ciphertext using the current decryption key.
        &#34;&#34;&#34;

        return self._get_plaintext(self._decryption_key)

    def reset(self):
        &#34;&#34;&#34;Reset the solver to its initial state.

        Set the decryption key to its initial state, effectively starting over.
        &#34;&#34;&#34;

        self._decryption_key = self._get_initial_key(self._ciphertext)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="markmag-ovn7.simple.SimpleSolver.solve"><code class="name flex">
<span>def <span class="ident">solve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve the cipher.</p>
<p>Run the solver and save the resulting decryption key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solve(self):
    &#34;&#34;&#34;Solve the cipher.

    Run the solver and save the resulting decryption key.
    &#34;&#34;&#34;

    # We currently use the slow, naive algorithm based on random key swaps.
    self._solve_naive()</code></pre>
</details>
</dd>
<dt id="markmag-ovn7.simple.SimpleSolver.plaintext"><code class="name flex">
<span>def <span class="ident">plaintext</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a plaintext using the current decryption key.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>plaintext</code></strong> :&ensp;<code>str</code></dt>
<dd>Plaintext from decrypting the ciphertext using the current decryption key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plaintext(self):
    &#34;&#34;&#34;Return a plaintext using the current decryption key.

    Returns
    -------
    plaintext : str
        Plaintext from decrypting the ciphertext using the current decryption key.
    &#34;&#34;&#34;

    return self._get_plaintext(self._decryption_key)</code></pre>
</details>
</dd>
<dt id="markmag-ovn7.simple.SimpleSolver.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Reset the solver to its initial state.</p>
<p>Set the decryption key to its initial state, effectively starting over.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;Reset the solver to its initial state.

    Set the decryption key to its initial state, effectively starting over.
    &#34;&#34;&#34;

    self._decryption_key = self._get_initial_key(self._ciphertext)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="markmag-ovn7" href="index.html">markmag-ovn7</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="markmag-ovn7.simple.SimpleSolver" href="#markmag-ovn7.simple.SimpleSolver">SimpleSolver</a></code></h4>
<ul class="">
<li><code><a title="markmag-ovn7.simple.SimpleSolver.solve" href="#markmag-ovn7.simple.SimpleSolver.solve">solve</a></code></li>
<li><code><a title="markmag-ovn7.simple.SimpleSolver.plaintext" href="#markmag-ovn7.simple.SimpleSolver.plaintext">plaintext</a></code></li>
<li><code><a title="markmag-ovn7.simple.SimpleSolver.reset" href="#markmag-ovn7.simple.SimpleSolver.reset">reset</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>